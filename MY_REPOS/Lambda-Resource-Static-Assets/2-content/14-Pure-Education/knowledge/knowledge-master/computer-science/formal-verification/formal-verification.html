<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>formal-verification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="formal-verification"><a href="https://en.wikipedia.org/wiki/Formal_verification">Formal verification</a></h1>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://cloudbootup.com/post/what-why-and-how-of-formal-methods.html">What, Why, and How of Formal Methods (2019)</a></li>
<li><a href="https://www.hillelwayne.com/post/why-dont-people-use-formal-methods/">Why don’t people use formal methods? (2019)</a> (<a href="https://news.ycombinator.com/item?id=18965274">HN</a>)</li>
<li><a href="https://github.com/FStarLang/FStar">F*</a> - Verification system for effectful programs.</li>
<li><a href="https://www.cl.cam.ac.uk/%7Ejrh13/hol-light/">HOL Light</a> - Computer program to help users prove interesting mathematical theorems completely formally in higher order logic.</li>
<li><a href="https://github.com/PrincetonUniversity/VST">Verified Software Toolchain</a> - Includes static analyzers to check assertions about your program; optimizing compilers to translate your program to machine language.</li>
<li><a href="http://plv.csail.mit.edu/">MIT Programming Languages &amp; Verification Group</a></li>
<li><a href="https://github.com/ProofSystem/Encyclopedia/blob/master/main.pdf">Encyclopedia of Proof Systems</a></li>
<li><a href="https://arxiv.org/pdf/1911.02679.pdf">A Domain-Specific Language for Verifying Software Requirement Constraints</a></li>
<li><a href="https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/alive/">Provably Correct Peephole Optimizations with Alive (2019)</a></li>
<li><a href="https://github.com/davecom/SwiftCSP">SwiftCSP</a> - Constraint satisfaction problem solver written in pure Swift.</li>
<li><a href="https://www.youtube.com/watch?v=GXXOyXeyKeY">Proof Assistants At the Hardware-Software Interface (2020)</a></li>
<li><a href="https://www.hillelwayne.com/post/business-case-formal-methods/">The business case for formal methods (2020)</a> (<a href="https://lobste.rs/s/ywgjhd/business_case_for_formal_methods">Lobsters</a>) (<a href="https://news.ycombinator.com/item?id=22321756">HN</a>)</li>
<li><a href="https://github.com/Deducteam/Logipedia">Logipedia</a> - Project that aims to share formal proofs between several systems.</li>
<li><a href="http://alloytools.org/about.html">Alloy</a> - Language for describing structures and a tool for exploring them. (<a href="https://alloy.readthedocs.io/en/latest/">Docs</a>) (<a href="https://www.hillelwayne.com/post/alloydocs/">Article</a>) (<a href="https://lobste.rs/s/g41wko/announcing_alloydocs">Lobsters</a>)</li>
<li><a href="http://softwareabstractions.org/">Software Abstractions book</a></li>
<li><a href="http://okmij.org/ftp/Computation/lightweight-static-guarantees.html">Safe and Efficient, Now</a></li>
<li><a href="https://lobste.rs/s/olecii/experiences_moving_from_tests_strong">Experiences moving from tests to strong typing? (2020)</a></li>
<li><a href="https://blog.regehr.org/archives/50">Margin in Software Systems (2010)</a></li>
<li><a href="https://sygus.org/">SyGuS competition</a> - Allow solvers for syntax-guided synthesis problems to compete on a large collection of benchmarks.</li>
<li><a href="https://alastairreid.github.io/verification-competitions/">Verification Competitions (2020)</a></li>
<li><a href="https://runtimeverification.com/blog/k-framework-an-overview/">K Framework – An Overview (2018)</a></li>
<li><a href="https://arxiv.org/abs/1905.09381">Learning to Prove Theorems via Interacting with Proof Assistants (2019)</a></li>
<li><a href="https://twitter.com/hillelogram/status/1258440258343112715">How do I rigorously translate a spec to implementation, and how do I keep them in sync? (2020)</a></li>
<li><a href="https://lobste.rs/s/fcntwr/what_are_you_doing_this_weekend#c_kesgdu">Engineering a Safer World notes</a></li>
<li><a href="https://cacm.acm.org/magazines/2019/2/234356-separation-logic/fulltext">Separation Logic (2019)</a></li>
<li><a href="https://github.com/ligurio/practical-fm">List of companies that use formal verification methods in software engineering</a></li>
<li><a href="https://www.youtube.com/watch?v=oMSmkRGzQ64">Formal Specification and Taming Other People’s Tech - Marianne Bellotti (2019)</a></li>
<li><a href="https://www.youtube.com/watch?v=5B7iI2onu8s">Verified Programming with Project Everest (2020)</a></li>
<li><a href="https://soap.coffee/~lthms/posts/AlgebraicDatatypes.html">Proving Algebraic Datatypes are “Algebraic” (2020)</a></li>
<li><a href="http://www.macs.hw.ac.uk/splv/">SPLV – Scottish Programming Languages and Verification Summer School</a></li>
<li><a href="https://backspace.ai/">backspace.ai</a> - Fun resource to start playing with formal programming languages.</li>
<li><a href="http://www.weaselhat.com/2020/08/07/formulog-ml-datalog-smt/">Formulog: ML + Datalog + SMT (2020)</a></li>
<li><a href="https://www.moritz.systems/blog/an-introduction-to-formal-verification/">An introduction to Formal Verification for Software Systems (2020)</a></li>
<li><a href="https://proofengineering.org/">Proof Engineering</a> - Specifying, building, verifying, and maintaining software systems using proof assistants such as Coq, Isabelle/HOL, and HOL4.</li>
<li><a href="https://event.cwi.nl/sefm2020/">Software Engineering and Formal Methods 2020</a></li>
<li><a href="https://jix.one/the-assembly-language-of-satisfiability/">The Assembly Language of Satisfiability (2020)</a></li>
<li><a href="https://homes.cs.washington.edu/~mernst/pubs/continuous-compliance-ase2020.pdf">Continuous compliance with lightweight verification tools (2020)</a></li>
<li><a href="https://runtimeverification.com/">Runtime Verification</a> - Startup company aimed at using runtime verification-based techniques to improve the safety, reliability, and correctness of software systems.</li>
<li><a href="https://github.com/GaloisInc/crucible">Crucible</a> - Language-agnostic library for performing forward symbolic execution of imperative programs. It provides a collection of data-structures and APIs for expressing programs as control-flow graphs. (<a href="https://crux.galois.com/">Web</a>) (<a href="https://galois.com/blog/2020/10/crux-introducing-our-new-open-source-tool-for-software-verification/">Intro</a>)</li>
<li><a href="https://github.com/o1-labs/snarky">snarky</a> - OCaml DSL for verifiable computation.</li>
<li><a href="https://galois.com/blog/2020/12/proofs-should-repair-themselves/">Proofs Should Repair Themselves (2020)</a> (<a href="https://lobste.rs/s/vh1edq/proofs_should_repair_themselves">Lobsters</a>)</li>
<li><a href="https://blog.gchinis.com/posts/use-polling-for-resiliency/">Use polling for resiliency (2020)</a> (<a href="https://lobste.rs/s/7vpobg/use_polling_for_resiliency">Lobsters</a>)</li>
<li><a href="http://www.fmeurope.org/documents/Garavel-terBeek-vandePol-20.pdf">The 2020 Expert Survey on Formal Methods</a></li>
<li><a href="https://fmie2021.github.io/">Formal Methods for the Informal Engineer (2020)</a></li>
<li><a href="https://sasnauskas.eu/finding-software-bugs-using-symbolic-execution/">Finding Software Bugs Using Symbolic Execution (2020)</a></li>
<li><a href="https://www.minizinc.org/">MiniZinc</a> - High-level constraint modelling language that allows you to easily express and solve discrete optimization problems. (<a href="https://github.com/MiniZinc/libminizinc">Code</a>) (<a href="https://sasnauskas.eu/solving-river-crossing-puzzles-with-minizinc/">Solving River Crossing Puzzles With MiniZinc</a>)</li>
<li><a href="https://www.mat.univie.ac.at/~neum/FMathL.html">FMathL</a> - Formal Mathematical Language.</li>
<li><a href="https://github.com/dafny-lang/dafny">Dafny</a> - Verification-aware programming language. (<a href="https://dafny-lang.github.io/dafny/">Docs</a>)</li>
<li><a href="http://www.dcs.gla.ac.uk/research/formalmethods/">Formal Methods Research Group - University of Glasgow</a></li>
<li><a href="https://www.springer.com/gp/book/9783030051556">Formal Methods: An Appetizer (2019)</a></li>
<li><a href="https://research.nccgroup.com/2021/01/29/software-verification-and-analysis-using-z3/">Software Verification and Analysis Using Z3 (2021)</a></li>
<li><a href="http://www.lix.polytechnique.fr/Labo/Samuel.Mimram/teaching/INF551/course.pdf">Program = Proof</a> - Gives a first introduction to the Curry-Howard correspondence between programs and proofs. (<a href="https://lobste.rs/s/d4ixfd/program_proof">Lobsters</a>)</li>
<li><a href="http://concrete-semantics.org/">Concrete Semantics</a> - Introduces semantics of programming languages through the medium of a proof assistant.</li>
</ul>
</body>
</html>
